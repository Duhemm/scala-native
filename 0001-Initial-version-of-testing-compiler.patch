From b625d61889fb1f0a978d783deba2c3d202ddb19e Mon Sep 17 00:00:00 2001
From: Martin Duhem <martin.duhem@gmail.com>
Date: Wed, 2 Nov 2016 15:06:19 +0100
Subject: [PATCH 01/13] Initial version of testing compiler

The testing compiler is made of two distinct components, as is the
scala-native compiler:
 - The testing NIRCompiler
 - The testing Optimizer

First, the testing NIRCompiler is used to compile scala code to NIR and
test the `nscplugin` project.

Second, the testing Optimizer is used to test the optimizer, and
ensuring that it performs the right transformations during its passes.
---
 .travis.yml                                        |   3 +-
 build.sbt                                          |  50 ++++++++
 .../compiler/api/CompilationFailedException.java   |   8 ++
 .../testing/compiler/api/NIRCompiler.java          |   8 ++
 .../scalanative/testing/compiler/NIRCompiler.scala | 127 +++++++++++++++++++++
 .../scalanative/testing/compiler/Compiler.scala    |  58 ++++++++++
 .../testing/utils/FilteredClassLoader.scala        |  17 +++
 .../testing/compiler/CompilerTest.scala            |  39 +++++++
 8 files changed, 308 insertions(+), 2 deletions(-)
 create mode 100644 testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/CompilationFailedException.java
 create mode 100644 testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/NIRCompiler.java
 create mode 100644 testing-compiler/src/main/scala/scalanative/testing/compiler/NIRCompiler.scala
 create mode 100644 testing-optimizer/src/main/scala/scala/scalanative/testing/compiler/Compiler.scala
 create mode 100644 testing-optimizer/src/main/scala/scala/scalanative/testing/utils/FilteredClassLoader.scala
 create mode 100644 testing-optimizer/src/test/scala/scala/scalanative/testing/compiler/CompilerTest.scala

diff --git a/.travis.yml b/.travis.yml
index 028c62a..55b22f5 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -54,5 +54,4 @@ script:
   - pushd sbt-cross
   - sbt publishLocal
   - popd
-  - bin/scalafmt --test && sbt 'cleanCache' 'cleanLocal' 'nscplugin/publishLocal' 'nativelib/publishLocal' 'publishLocal' 'sandbox/run' 'demoNative/run' 'tests/run' 'tools/test' 'benchmarks/run' 'scripted' 'publishSnapshot'
-
+  - bin/scalafmt --test && sbt 'cleanCache' 'cleanLocal' 'nscplugin/publishLocal' 'nativelib/publishLocal' 'publishLocal' 'sandbox/run' 'demoNative/run' 'tests/run' 'tools/test' 'testingCompiler/test' 'benchmarks/run' 'scripted' 'publishSnapshot'
diff --git a/build.sbt b/build.sbt
index b8baa37..ca088c2 100644
--- a/build.sbt
+++ b/build.sbt
@@ -365,3 +365,53 @@ lazy val benchmarks =
       }.taskValue
     )
     .enablePlugins(ScalaNativePlugin)
+
+lazy val testingOptimizer =
+  project
+    .in(file("testing-optimizer"))
+    .settings(toolSettings)
+    .settings(
+      fullClasspath in Test := {
+        val testingcompilercp = (fullClasspath in testingCompiler in Compile).value.files.map(_.getAbsolutePath)
+        val testingcompilerjar = (Keys.`package` in testingCompiler in Compile).value.getAbsolutePath
+        sys.props("sbt.paths.testingcompiler.cp") = (testingcompilercp :+ testingcompilerjar) mkString java.io.File.pathSeparator
+        (fullClasspath in Test).value
+      }
+    )
+    .settings(
+        libraryDependencies += "org.scalatest" %% "scalatest" % "3.0.0" % Test
+    )
+    .dependsOn(testingCompilerInterface)
+
+lazy val testingCompilerInterface =
+  project
+    .in(file("testing-compiler-interface"))
+    .settings(libSettings)
+    .settings(
+      crossPaths := false,
+      crossVersion := CrossVersion.Disabled,
+      autoScalaLibrary := false
+    )
+
+lazy val testingCompiler =
+  project
+    .in(file("testing-compiler"))
+    .settings(libSettings)
+    .settings(noPublishSettings)
+    .settings(
+      libraryDependencies ++= Seq(
+        "org.scala-lang" % "scala-compiler" % scalaVersion.value,
+        "org.scala-lang" % "scala-reflect"  % scalaVersion.value,
+        "org.scalatest" %% "scalatest" % "3.0.0" % Test
+      )
+    ).dependsOn(testingCompilerInterface, nativelib)
+    .settings(
+      fullClasspath in Test := {
+        val testcp = (fullClasspath in Test).value.files.map(_.getAbsolutePath).mkString(java.io.File.pathSeparator)
+        sys.props("sbt.class.directory") = testcp
+
+        val nscpluginjar = (Keys.`package` in nscplugin in Compile).value
+        sys.props("sbt.paths.scalanative.jar") = nscpluginjar.getAbsolutePath
+        (fullClasspath in Test).value
+      }
+    )
diff --git a/testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/CompilationFailedException.java b/testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/CompilationFailedException.java
new file mode 100644
index 0000000..23fe179
--- /dev/null
+++ b/testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/CompilationFailedException.java
@@ -0,0 +1,8 @@
+package scala.scalanative.testing.compiler.api;
+
+public class CompilationFailedException extends Exception {
+    public CompilationFailedException(String message) {
+        super(message);
+    }
+}
+
diff --git a/testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/NIRCompiler.java b/testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/NIRCompiler.java
new file mode 100644
index 0000000..7e64e01
--- /dev/null
+++ b/testing-compiler-interface/src/main/java/scala/scalanative/testing/compiler/api/NIRCompiler.java
@@ -0,0 +1,8 @@
+package scala.scalanative.testing.compiler.api;
+
+import java.io.File;
+
+public interface NIRCompiler {
+    public File[] getNIR(String source);
+    public File[] getNIR(File base);
+}
diff --git a/testing-compiler/src/main/scala/scalanative/testing/compiler/NIRCompiler.scala b/testing-compiler/src/main/scala/scalanative/testing/compiler/NIRCompiler.scala
new file mode 100644
index 0000000..0f7306e
--- /dev/null
+++ b/testing-compiler/src/main/scala/scalanative/testing/compiler/NIRCompiler.scala
@@ -0,0 +1,127 @@
+package scala.scalanative.testing
+package compiler
+
+import scala.reflect.internal.util.{BatchSourceFile, NoFile, SourceFile}
+import scala.reflect.internal.util.Position
+
+import scala.tools.cmd.CommandLineParser
+import scala.tools.nsc.{CompilerCommand, Global, Settings}
+import scala.tools.nsc.io.{AbstractFile, VirtualDirectory}
+import scala.tools.nsc.reporters.AbstractReporter
+
+import java.nio.file.Files
+import java.io.File
+
+/**
+ * Helper class to compile snippets of code.
+ */
+class NIRCompiler(outputDir: File) extends api.NIRCompiler {
+
+  def this() = this(Files.createTempDirectory("scala-native-target").toFile())
+
+  /**
+   * Compiles the given code, and returns the `.hnir` files.
+   */
+  override def getNIR(code: String): Array[File] = {
+    val source = new BatchSourceFile(NoFile, code)
+    getNIR(Seq(source)).toArray
+  }
+
+  /**
+   * Compiles the given file, and returns the `.hnir` files.
+   */
+  override def getNIR(base: File): Array[File] = {
+    val sources = getFiles(base, _.getName endsWith ".scala")
+    val sourceFiles = sources map { s =>
+      val abstractFile = AbstractFile.getFile(s)
+      new BatchSourceFile(abstractFile)
+    }
+    getNIR(sourceFiles).toArray
+  }
+
+  /**
+   * Compiles the given files, and returns the `.hnir` files.
+   */
+  private def getNIR(sources: Seq[SourceFile]): Seq[File] = {
+    val global = getCompiler(options = ScalaNative)
+    import global._
+    val run = new Run
+    run.compileSources(sources.toList)
+    getFiles(outputDir, _.getName endsWith ".hnir")
+  }
+
+  /**
+   * List of the files contained in `base` that sastisfy `filter`
+   */
+  private def getFiles(base: File, filter: File => Boolean): Seq[File] =
+    (if (filter(base)) Seq(base) else Seq()) ++
+      (Option(base.listFiles()) getOrElse Array.empty flatMap (getFiles(
+        _,
+        filter)))
+
+
+  private def reportError(error: String) = throw new api.CompilationFailedException(error)
+
+  /**
+   * Reporter that ignores INFOs and WARNINGs, but directly aborts the compilation
+   * on ERRORs.
+   */
+  private class TestReporter(override val settings: Settings)
+      extends AbstractReporter {
+    override def display(pos: Position,
+                         msg: String,
+                         severity: Severity): Unit = severity match {
+      case INFO | WARNING => ()
+      case ERROR          => reportError(msg)
+    }
+
+    override def displayPrompt(): Unit = ()
+  }
+
+  /**
+   * Represents a basic compiler option (the string given to the command line invocation
+   * of scalac)
+   */
+  private implicit class CompilerOption(s: String) {
+    override def toString: String = s
+  }
+
+  /**
+   * An option to add a compiler plugin
+   */
+  private class CompilerPlugin(val jarPath: String,
+                               val classpath: List[String])
+      extends CompilerOption(
+        s"-Xplugin:$jarPath" + (if (classpath.nonEmpty)
+                                  classpath.mkString(" -cp ", ":", "")
+                                else ""))
+
+  /**
+   * Option to add the scala-native compiler plugin
+   */
+  private case object ScalaNative
+      extends CompilerPlugin(jarPath = sys props "sbt.paths.scalanative.jar",
+                             classpath =
+                               List(sys props "sbt.class.directory",
+                                    sys props "sbt.paths.scalanative.jar"))
+
+  /**
+   * Returns an instance of `Global` configured according to the given options.
+   */
+  private def getCompiler(options: CompilerOption*): Global = {
+    // I don't really know how I can reset the compiler after a run, nor what else
+    // should also be reset, so for now this method creates new instances of everything,
+    // which is not so cool.
+    //
+    // Also, using `command.settings.outputDirs.setSingleOutput` I get strange classpath problems.
+    // What's even stranger, is that everything works fine using `-d`!
+    val outPath = outputDir.getAbsolutePath
+    val arguments =
+      CommandLineParser.tokenize(s"-d $outPath " + (options mkString " "))
+    val command  = new CompilerCommand(arguments.toList, reportError _)
+    val reporter = new TestReporter(command.settings)
+
+    new Global(command.settings, reporter)
+  }
+
+}
diff --git a/testing-optimizer/src/main/scala/scala/scalanative/testing/compiler/Compiler.scala b/testing-optimizer/src/main/scala/scala/scalanative/testing/compiler/Compiler.scala
new file mode 100644
index 0000000..b8b97ad
--- /dev/null
+++ b/testing-optimizer/src/main/scala/scala/scalanative/testing/compiler/Compiler.scala
@@ -0,0 +1,58 @@
+package scala.scalanative
+package testing
+package compiler
+
+import java.nio.file.Files
+import java.io.{ File, PrintWriter }
+import java.net.URLClassLoader
+
+import utils.FilteredClassLoader
+import compiler.api.NIRCompiler
+
+object Compiler {
+
+  private val allow: String => Boolean =
+    n => n.startsWith("scala.scalanative.testing.compiler.api.") || !n.startsWith("scala.")
+
+  private val classLoader = {
+    val parts = sys.props("sbt.paths.testingcompiler.cp").split(":").map(new java.io.File(_)).filter(f=> f.exists && f.getName.endsWith(".jar")).map(_.toURI.toURL)
+
+    // We must share some parts of our classpath with the classloader used for the NIR compiler,
+    // because we want to be able to cast the NIRCompiler that we get back to its interface and
+    // be able to use it seamlessly.
+    // We filter out the scala library from out classloader (so that it gets delegated to the
+    // scala library that is in `sbt.paths.testingcompiler.cp`, and we keep `api.NIRCompiler`.
+    val parent = new FilteredClassLoader(allow, this.getClass.getClassLoader)
+    new URLClassLoader(parts.toArray, parent)
+  }
+
+  def getCompiler(): NIRCompiler = {
+    val clazz = classLoader.loadClass("scala.scalanative.testing.compiler.NIRCompiler")
+    clazz.newInstance match {
+      case compiler: NIRCompiler => compiler
+      case other                 => throw new Exception("WTF: " + other.getClass.getName)
+    }
+  }
+
+  def apply[T](fn: NIRCompiler => T): T =
+    withSources(Map.empty) { case (_, compiler) => fn(compiler) }
+
+  def withSources[T](sources: Map[String, String])(fn: (File, api.NIRCompiler) => T): T = {
+    val sourcesDir = writeSources(sources)
+    fn(sourcesDir, getCompiler())
+  }
+
+  private def writeSources(sources: Map[String, String]): File = {
+    val baseDir = Files.createTempDirectory("scala-native-sources").toFile()
+    sources foreach { case (name, content) => makeFile(baseDir, name, content) }
+    baseDir
+  }
+
+  private def makeFile(base: File, name: String, content: String): Unit = {
+    val writer = new PrintWriter(new File(base, name))
+    writer.write(content)
+    writer.close()
+  }
+
+}
+
diff --git a/testing-optimizer/src/main/scala/scala/scalanative/testing/utils/FilteredClassLoader.scala b/testing-optimizer/src/main/scala/scala/scalanative/testing/utils/FilteredClassLoader.scala
new file mode 100644
index 0000000..75bc6ac
--- /dev/null
+++ b/testing-optimizer/src/main/scala/scala/scalanative/testing/utils/FilteredClassLoader.scala
@@ -0,0 +1,17 @@
+package scala.scalanative
+package testing
+package utils
+
+/**
+ * A `ClassLoader` that will let `parent` load classes that satisfy `allow`, and
+ * throw a `ClassNotFoundException` for all other classes.
+ */
+class FilteredClassLoader(allow: String => Boolean, parent: ClassLoader) extends ClassLoader(parent) {
+
+  override def loadClass(className: String, resolve: Boolean): Class[_] =
+    if (allow(className))
+      super.loadClass(className, resolve)
+    else
+      throw new ClassNotFoundException(className)
+
+}
diff --git a/testing-optimizer/src/test/scala/scala/scalanative/testing/compiler/CompilerTest.scala b/testing-optimizer/src/test/scala/scala/scalanative/testing/compiler/CompilerTest.scala
new file mode 100644
index 0000000..bfab716
--- /dev/null
+++ b/testing-optimizer/src/test/scala/scala/scalanative/testing/compiler/CompilerTest.scala
@@ -0,0 +1,39 @@
+package scala.scalanative
+package testing
+package compiler
+
+import org.scalatest._
+
+class CompilerTest extends FlatSpec with Matchers {
+
+  "The compiler" should "be able to get NIR files"in {
+    val files = Compiler { _ getNIR "class A" }
+    files should have length 1
+    files(0).getName should be ("A.hnir")
+  }
+
+  it should "compile whole directories" in {
+    val sources = Map(
+      "A.scala" -> "class A",
+      "B.scala" -> "class B extends A",
+      "C.scala" -> "trait C",
+      "D.scala" -> """class D extends B with C
+                     |object E""".stripMargin
+    )
+
+    Compiler.withSources(sources) {
+      case (sourcesDir, compiler) =>
+        val nirFiles = compiler.getNIR(sourcesDir) map (_.getName)
+        val expectedNames =
+          Seq("E$.hnir", "A.hnir", "B.hnir", "C.hnir", "D.hnir")
+        nirFiles should contain theSameElementsAs expectedNames
+    }
+  }
+
+  it should "report compilation errors" in {
+    assertThrows[api.CompilationFailedException] {
+      Compiler { _ getNIR "invalid" }
+    }
+  }
+
+}
-- 
2.9.3 (Apple Git-75)

