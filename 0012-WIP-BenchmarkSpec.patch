From 659e4c0920754a94392775089162ef733eacd742 Mon Sep 17 00:00:00 2001
From: Martin Duhem <martin.duhem@gmail.com>
Date: Thu, 8 Dec 2016 07:42:11 +0100
Subject: [PATCH 12/13] (WIP) BenchmarkSpec

---
 .../scala/scala/scalanative/BenchmarkSpec.scala    | 75 ++++++++++++++++++++++
 .../test/scala/scala/scalanative/BinarySpec.scala  | 24 +++++--
 2 files changed, 92 insertions(+), 7 deletions(-)
 create mode 100644 tools/src/test/scala/scala/scalanative/BenchmarkSpec.scala

diff --git a/tools/src/test/scala/scala/scalanative/BenchmarkSpec.scala b/tools/src/test/scala/scala/scalanative/BenchmarkSpec.scala
new file mode 100644
index 0000000..79e3c22
--- /dev/null
+++ b/tools/src/test/scala/scala/scalanative/BenchmarkSpec.scala
@@ -0,0 +1,75 @@
+package scala.scalanative
+
+import java.io.File
+
+import optimizer.Driver
+
+abstract class BenchmarkSpec extends BinarySpec {
+
+  case class BenchmarkResult(minNs: Long, maxNs: Long, avgNs: Long) {
+    override def toString(): String = {
+      def toMs(ns: Long): Double = ns.toDouble / 1000.0
+      val format = new java.text.DecimalFormat("#.###")
+      val minMs = format.format(toMs(minNs))
+      val maxMs = format.format(toMs(maxNs))
+      val avgMs = format.format(toMs(avgNs))
+      s"min = ${minMs}ms, max = ${maxMs}ms, avg = ${avgMs}ms"
+    }
+  }
+
+  private def timed[T](op: => T): Long = {
+    val startTime = System.nanoTime()
+    val _         = op
+    System.nanoTime - startTime
+  }
+
+  private def run(iterations: Int, binary: File): BenchmarkResult = {
+    var minNs     = Long.MaxValue
+    var maxNs     = Long.MinValue
+    val total = timed {
+      for { _ <- 1 to iterations } {
+        val time = timed { run(binary) { case _ => () } }
+        minNs = minNs min time
+        maxNs = maxNs max time
+      }
+    }
+    BenchmarkResult(minNs, maxNs, total)
+  }
+
+  private def makeMain(entry: String,
+                       iterations: Int): String = {
+    val call = "A.main(args)\n" * iterations
+    s"""object Benchmark {
+       |  def main(args: Array[String]): Unit = {
+       |    $call
+       |  }
+       |}""".stripMargin
+  }
+
+  def benchmark[T](entry: String,
+                   baseDriver: Driver,
+                   improvedDriver: Driver,
+                   iterations: Int,
+                   sources: Map[String, String],
+                   linkage: Map[String, String] = Map.empty,
+                   opts: Seq[String] = defaultClangOptions)(fn: (BenchmarkResult, BenchmarkResult) => T): T = {
+
+    val newSources =
+      sources + ("Benchmark.scala" -> makeMain(xentry, iterations))
+    val newEntry =
+      "Benchmark$"
+
+    val baseResult =
+      makeBinary(newEntry, newSources, baseDriver, linkage, opts) {
+        case (_, _, baseBinary) => run(iterations, baseBinary)
+      }
+
+    val improvedResult =
+      makeBinary(newEntry, newSources, improvedDriver, linkage, opts) {
+        case (_, _, improvedBinary) => run(iterations, improvedBinary)
+      }
+
+    fn(baseResult, improvedResult)
+  }
+
+}
diff --git a/tools/src/test/scala/scala/scalanative/BinarySpec.scala b/tools/src/test/scala/scala/scalanative/BinarySpec.scala
index 01eb73c..34f998a 100644
--- a/tools/src/test/scala/scala/scalanative/BinarySpec.scala
+++ b/tools/src/test/scala/scala/scalanative/BinarySpec.scala
@@ -85,15 +85,25 @@ abstract class BinarySpec extends CodeGenSpec {
              opts: Seq[String] = defaultClangOptions)(
       fn: (Int, Seq[String], Seq[String]) => T): T =
     makeBinary(entry, sources, driver, linkage, opts) {
-      case (_, _, binary) =>
-        val outLines = scala.collection.mutable.Buffer.empty[String]
-        val errLines = scala.collection.mutable.Buffer.empty[String]
-        val logger   = ProcessLogger(outLines += _, errLines += _)
-        val exitCode = Process(binary.getAbsolutePath) ! logger
-
-        fn(exitCode, outLines, errLines)
+      case (_, _, binary) => run(binary)(fn)
     }
 
+  /**
+   * Runs the given binary file.
+   *
+   * @param binary The binary file to run.
+   * @param fn     A function to apply to the output of the run.
+   * @return The result of applying `fn` to the output of the run.
+   */
+  def run[T](binary: File)(fn: (Int, Seq[String], Seq[String]) => T): T = {
+    val outLines = scala.collection.mutable.Buffer.empty[String]
+    val errLines = scala.collection.mutable.Buffer.empty[String]
+    val logger   = ProcessLogger(outLines += _, errLines += _)
+    val exitCode = Process(binary.getAbsolutePath) ! logger
+
+    fn(exitCode, outLines, errLines)
+  }
+
   private def write(virtual: VirtualFile): File = {
     val out = createTempFile("native-codegen", ".ll").toFile()
     val channel =
-- 
2.9.3 (Apple Git-75)

